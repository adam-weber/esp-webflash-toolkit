<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript API - ESP WebFlash Toolkit</title>
    <link rel="stylesheet" href="shared-styles.css">
    <script>
        // Apply dark mode immediately to prevent flash
        (function() {
            const savedMode = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedMode === 'dark' || (!savedMode && prefersDark)) {
                document.documentElement.classList.add('dark-mode');
            }
        })();
    </script>
    <link rel="stylesheet" href="docs-styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</head>
<body>
    <div id="navbar-container"></div>

    <nav class="sidebar">
        <!-- Sidebar content will be dynamically generated by docs-sidebar.js -->
    </nav>

    <div class="container">
        <div id="javascript" class="lesson">
            <h2>JavaScript API Reference</h2>
            <p class="lesson-intro">Function signatures and parameters for NVS binary generation in JavaScript. Compatible with browser and Node.js environments.</p>

            <h3 id="installation">Installation</h3>
            <pre><code class="language-html">&lt;script src="https://jctoledo.github.io/active_wing/dist/nvs-generator.js"&gt;&lt;/script&gt;</code></pre>

            <h3 id="nvsgenerator">NVSGenerator</h3>

            <h4>Constructor</h4>
            <pre><code class="language-javascript">new NVSGenerator()</code></pre>
            <p>Creates a new NVS generator instance. No parameters required.</p>

            <h4>generate(config, size)</h4>
            <p>Generates an NVS partition binary from a configuration object.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>config</code> (Object) - Configuration data structured as namespaces containing key-value pairs</li>
                <li><code>size</code> (Number) - Partition size in bytes (hexadecimal or decimal)</li>
            </ul>

            <p><strong>Returns:</strong> <code>Uint8Array</code> - Binary data ready for flashing</p>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">const generator = new NVSGenerator();
const config = {
    wifi: { ssid: "Network", password: "pass123" },
    mqtt: { broker: "192.168.1.100", port: 1883 }
};
const binary = generator.generate(config, 0x6000);  // 24KB partition</code></pre>

            <p><strong>Notes:</strong></p>
            <ul>
                <li>Top-level object keys define NVS namespaces</li>
                <li>Nested keys define entries within namespaces</li>
                <li>Data types inferred from JavaScript types (string, number, boolean)</li>
                <li>Strings limited to 1984 bytes per entry</li>
            </ul>

            <h4>NVSGenerator.calculateSize(config)</h4>
            <p>Calculates appropriate partition size for a given configuration.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>config</code> (Object) - Configuration object to analyze</li>
            </ul>

            <p><strong>Returns:</strong> <code>Object</code></p>
            <pre><code class="language-javascript">{
    minimum: Number,      // Minimum viable size (hex)
    recommended: Number,  // Recommended size with headroom (hex)
    entries: Number,      // Total number of key-value pairs
    pagesUsed: Number,    // Pages required for entries
    pagesTotal: Number    // Total pages in recommended size
}</code></pre>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">const sizeInfo = NVSGenerator.calculateSize(config);
console.log(sizeInfo.recommended);  // 0x6000
const binary = generator.generate(config, sizeInfo.recommended);</code></pre>

            <p><strong>Notes:</strong></p>
            <ul>
                <li>Accounts for ESP-IDF minimum (3 pages / 12KB)</li>
                <li>Recommended size provides 2× minimum for wear leveling</li>
                <li>Each page holds 126 entries (4096 bytes: 32-byte header + 126 × 32-byte entries)</li>
            </ul>

            <h3 id="detectnvspartition">detectNVSPartition(espLoader)</h3>
            <p>Reads partition table from device flash and returns NVS partition information.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>espLoader</code> (ESPLoader) - Connected esptool-js loader instance</li>
            </ul>

            <p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code></p>
            <pre><code class="language-javascript">{
    offset: Number,  // Flash address of NVS partition (hex)
    size: Number,    // Partition size in bytes (hex)
    label: String    // Partition label from table
}</code></pre>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">const partition = await detectNVSPartition(espLoader);
const binary = generator.generate(config, partition.size);
await espLoader.writeFlash({
    fileArray: [{ data: binaryToString(binary), address: partition.offset }],
    flashSize: 'keep'
});</code></pre>

            <p><strong>Requirements:</strong></p>
            <ul>
                <li>Firmware must be flashed with partition table</li>
                <li>Partition table at standard location (0x8000)</li>
                <li>Partition table must be unencrypted</li>
            </ul>

            <p><strong>Throws:</strong> Error if partition table cannot be read or parsed</p>

            <p><strong>Notes:</strong></p>
            <ul>
                <li>Returns first partition with type=data, subtype=nvs</li>
                <li>Reads from flash offset 0x8000 (ESP-IDF default)</li>
                <li>Fails on blank chips or custom partition layouts</li>
            </ul>

            <h3 id="deviceconnection">DeviceConnection</h3>
            <p>Manages serial connection to ESP32 devices via Web Serial API.</p>

            <h4>Constructor</h4>
            <pre><code class="language-javascript">new DeviceConnection(ui)</code></pre>
            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>ui</code> (FlasherUI) - UI instance for status updates and logging</li>
            </ul>

            <h4>connect(project, options)</h4>
            <p>Establish serial connection and detect chip type.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>project</code> (Object) - Project configuration with chip type and settings</li>
                <li><code>options</code> (Object) - Connection options:
                    <ul>
                        <li><code>port</code> (SerialPort, optional) - Pre-selected port for auto-reconnect</li>
                        <li><code>skipChipCheck</code> (Boolean, default: false) - Skip chip type validation</li>
                    </ul>
                </li>
            </ul>

            <p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code></p>
            <pre><code class="language-javascript">{
    chipType: String,  // Detected chip (e.g., "ESP32-C3")
    macAddr: String    // Device MAC address
}</code></pre>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">const connection = new DeviceConnection(ui);
const { chipType, macAddr } = await connection.connect(project);
console.log(`Connected to ${chipType} (${macAddr})`);</code></pre>

            <p><strong>Throws:</strong> Error on connection failure, chip mismatch (if user cancels), or timeout</p>

            <h4>disconnect()</h4>
            <p>Close serial connection and clean up resources.</p>
            <p><strong>Returns:</strong> <code>Promise&lt;void&gt;</code></p>

            <h4>readFlash(offset, size)</h4>
            <p>Read data from device flash memory.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>offset</code> (Number) - Flash address in bytes (e.g., 0x9000)</li>
                <li><code>size</code> (Number) - Number of bytes to read</li>
            </ul>

            <p><strong>Returns:</strong> <code>Promise&lt;Uint8Array&gt;</code> - Flash data</p>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">// Read NVS partition from 0x9000 (24KB)
const nvsData = await connection.readFlash(0x9000, 0x6000);
const config = parseNVSConfig(nvsData);</code></pre>

            <h4>getESPStub()</h4>
            <p>Get esptool-js loader instance for direct flash operations.</p>
            <p><strong>Returns:</strong> <code>ESPLoader</code> - Active loader instance or null</p>

            <h4>getIsConnected()</h4>
            <p>Check connection status.</p>
            <p><strong>Returns:</strong> <code>Boolean</code> - True if connected</p>

            <h3 id="configmanager">ConfigManager</h3>
            <p>Handles configuration form rendering and persistence.</p>

            <h4>Constructor</h4>
            <pre><code class="language-javascript">new ConfigManager()</code></pre>
            <p>Automatically loads saved configuration from localStorage.</p>

            <h4>renderConfigFields(project)</h4>
            <p>Generate configuration form from project definition.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>project</code> (Object) - Project with configSections array defining form structure</li>
            </ul>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">const manager = new ConfigManager();
manager.renderConfigFields({
    configSections: [{
        id: 'wifi',
        title: 'WiFi Settings',
        fields: [
            { id: 'ssid', label: 'SSID', type: 'text', required: true, nvsKey: 'wifi_ssid' },
            { id: 'password', label: 'Password', type: 'password', required: true, nvsKey: 'wifi_pass' }
        ]
    }]
});</code></pre>

            <h4>getConfig()</h4>
            <p>Get current configuration values.</p>
            <p><strong>Returns:</strong> <code>Object</code> - Configuration organized by section ID</p>
            <pre><code class="language-javascript">{
    wifi: { ssid: "MyNetwork", password: "secret123" },
    mqtt: { broker: "192.168.1.100", port: 1883 }
}</code></pre>

            <h4>populateFromNVS(nvsData, project)</h4>
            <p>Load configuration from device into form fields.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>nvsData</code> (Object) - Parsed NVS data (key-value pairs)</li>
                <li><code>project</code> (Object) - Project definition with field mappings</li>
            </ul>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">const flashData = await connection.readFlash(0x9000, 0x6000);
const nvsData = parseNVSConfig(flashData);
manager.populateFromNVS(nvsData, project);</code></pre>

            <h4>saveConfig()</h4>
            <p>Persist current configuration to localStorage.</p>

            <h4>clearConfig()</h4>
            <p>Clear all configuration values and reload form.</p>

            <h3 id="firmwareflasher">FirmwareFlasher</h3>
            <p>Handles firmware download, NVS generation, and flashing operations.</p>

            <h4>Constructor</h4>
            <pre><code class="language-javascript">new FirmwareFlasher(ui, configManager)</code></pre>
            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>ui</code> (FlasherUI) - UI instance for status and progress</li>
                <li><code>configManager</code> (ConfigManager) - Config manager for NVS generation</li>
            </ul>

            <h4>flash(project, espStub, options)</h4>
            <p>Flash firmware and configuration to device.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>project</code> (Object) - Project configuration</li>
                <li><code>espStub</code> (ESPLoader) - Connected esptool-js instance</li>
                <li><code>options</code> (Object, optional) - Flash options:
                    <ul>
                        <li><code>customFirmware</code> (File, optional) - Custom .bin file instead of downloading from release</li>
                    </ul>
                </li>
            </ul>

            <p><strong>Returns:</strong> <code>Promise&lt;Boolean&gt;</code> - True on success</p>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">const flasher = new FirmwareFlasher(ui, configManager);
const espStub = connection.getESPStub();
await flasher.flash(project, espStub);</code></pre>

            <p><strong>Throws:</strong> Error on download failure, flash error, or NVS generation error</p>

            <p><strong>Notes:</strong></p>
            <ul>
                <li>Downloads firmware from project.firmwareUrl unless customFirmware provided</li>
                <li>Automatically generates and flashes NVS partition if project.nvsPartition exists</li>
                <li>Reports progress via ui.updateProgress() callback</li>
                <li>Flashes firmware at 0x0 (includes bootloader, partition table, app)</li>
            </ul>

            <h3 id="flasherui">FlasherUI</h3>
            <p>Manages UI state, progress indicators, and logging.</p>

            <h4>Constructor</h4>
            <pre><code class="language-javascript">new FlasherUI()</code></pre>
            <p>Automatically binds to DOM elements by ID.</p>

            <h4>updateStatus(state, text, subtext)</h4>
            <p>Update status indicator.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>state</code> (String) - Status: 'waiting', 'connected', 'flashing', 'success', 'error'</li>
                <li><code>text</code> (String) - Main status text</li>
                <li><code>subtext</code> (String) - Detailed status message</li>
            </ul>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">ui.updateStatus('connected', 'Device connected', 'Ready to flash');</code></pre>

            <h4>updateProgress(percent, written, total)</h4>
            <p>Update progress bar with smooth animation.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>percent</code> (Number) - Completion percentage (0-100)</li>
                <li><code>written</code> (Number) - Bytes written</li>
                <li><code>total</code> (Number) - Total bytes</li>
            </ul>

            <h4>showProgress() / hideProgress()</h4>
            <p>Show or hide progress indicator.</p>

            <h4>log(message, type)</h4>
            <p>Add timestamped log entry to console.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>message</code> (String) - Log message</li>
                <li><code>type</code> (String, default: 'info') - Type: 'info', 'success', 'warning', 'error'</li>
            </ul>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">ui.log('Downloading firmware...', 'info');
ui.log('Flash complete!', 'success');</code></pre>

            <h4>updateChipInfo(chipType, macAddr)</h4>
            <p>Display detected chip information.</p>

            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>chipType</code> (String) - Chip model (e.g., "ESP32-C3")</li>
                <li><code>macAddr</code> (String) - MAC address</li>
            </ul>

            <h4>clearLog()</h4>
            <p>Clear console output.</p>

            <h3 id="flasherapp">FlasherApp</h3>
            <p>Main application coordinator integrating all components.</p>

            <h4>Constructor</h4>
            <pre><code class="language-javascript">new FlasherApp(projects)</code></pre>
            <p><strong>Parameters:</strong></p>
            <ul>
                <li><code>projects</code> (Object) - Project definitions keyed by project ID</li>
            </ul>

            <p><strong>Example:</strong></p>
            <pre><code class="language-javascript">const app = new FlasherApp({
    'my-project': {
        name: 'My ESP32 Project',
        chip: 'ESP32-C3',
        firmwareUrl: 'https://github.com/user/repo/releases/download/v1.0/firmware.bin',
        nvsPartition: { offset: '0x9000', size: '0x6000', namespace: 'config' },
        configSections: [/* ... */]
    }
});</code></pre>

            <p><strong>Notes:</strong></p>
            <ul>
                <li>Automatically initializes all components (UI, ConfigManager, DeviceConnection, FirmwareFlasher)</li>
                <li>Checks browser compatibility (Web Serial API)</li>
                <li>Attempts auto-reconnect to previously connected device</li>
                <li>Handles all UI event listeners and workflows</li>
            </ul>


            <h3 id="verification">Output Verification</h3>
            <p>Binary compatibility verification against ESP-IDF reference implementation:</p>
            <pre><code class="language-bash"># Generate with ESP-IDF
echo "config,namespace,," > test.csv
echo "port,data,u16,1883" >> test.csv
python -m esp_idf_nvs_partition_gen generate test.csv test_esp.bin 0x6000

# Generate with this library
node -e "
const gen = new (require('./nvs-generator.js'))();
const bin = gen.generate({config: {port: 1883}}, 0x6000);
require('fs').writeFileSync('test_js.bin', Buffer.from(bin));
"

# Compare
diff test_esp.bin test_js.bin
# Should be identical</code></pre>
        </div>
    </div>

    <script src="shared-nav.js"></script>
    <script src="docs-scripts.js"></script>
    <script>
        // Store reference to page subnav BEFORE docs-sidebar.js loads
        let pageSubnav = null;
        document.addEventListener('DOMContentLoaded', () => {
            pageSubnav = document.querySelector('.page-subnav');
        });
    </script>
    <script src="docs-sidebar.js"></script>
    <script>
        // Page sub-navigation active state based on scroll position
        document.addEventListener('DOMContentLoaded', () => {
            const sections = ['installation', 'nvsgenerator', 'detectnvspartition', 'deviceconnection',
                            'configmanager', 'firmwareflasher', 'flasherui', 'flasherapp', 'verification'];
            const navLinks = {};

            sections.forEach(id => {
                navLinks[id] = document.querySelector(`.page-subnav-link[href="#${id}"]`);
            });

            function updateActiveNav() {
                const scrollPos = window.scrollY + 120; // Offset for sticky header

                let currentSection = sections[0];
                sections.forEach(id => {
                    const section = document.getElementById(id);
                    if (section && section.offsetTop <= scrollPos) {
                        currentSection = id;
                    }
                });

                // Update active states
                sections.forEach(id => {
                    if (navLinks[id]) {
                        if (id === currentSection) {
                            navLinks[id].classList.add('active');
                        } else {
                            navLinks[id].classList.remove('active');
                        }
                    }
                });
            }

            // Update on scroll with throttle
            let ticking = false;
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        updateActiveNav();
                        ticking = false;
                    });
                    ticking = true;
                }
            });

            // Initial update
            updateActiveNav();
        });
    </script>
</body>
</html>
