<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firmware Router - ESP WebFlash Toolkit</title>
    <link rel="stylesheet" href="shared-styles.css">
    <script>
        // Apply dark mode immediately to prevent flash
        (function() {
            const savedMode = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedMode === 'dark' || (!savedMode && prefersDark)) {
                document.documentElement.classList.add('dark-mode');
            }
        })();
    </script>
    <link rel="stylesheet" href="docs-styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</head>
<body>
    <div id="navbar-container"></div>

    <nav class="sidebar">
        <!-- Sidebar content will be dynamically generated by docs-sidebar.js -->
    </nav>

    <div class="container">
        <div id="router" class="lesson">
            <h2>Firmware Router</h2>
            <p class="lesson-intro">Single-method abstraction for multi-variant ESP32 firmware deployment. Chip detection, firmware selection, and NVS generation handled automatically.</p>

            <h3>Minimal API</h3>
            <p>The router abstracts all esptool-js operations, chip detection, and binary management into a single method call:</p>

            <pre><code class="language-javascript">const router = new FirmwareRouter('/firmware');  // Base path to firmware directory

await router.flash({
    config: { wifi: { ssid: "Network", password: "pass123" } },
    onProgress: (percent, stage) => {
        console.log(`${stage}: ${percent}%`);
    }
});
// Complete: chip detected, firmware selected, NVS generated, device flashed</code></pre>

            <h3>Directory Convention</h3>
            <p>The router expects a standard directory structure. No configuration mapping required:</p>

            <pre><code class="language-bash">/firmware/
  ├── esp32/
  │   ├── bootloader.bin
  │   ├── partitions.bin
  │   └── app.bin
  ├── esp32c3/
  │   ├── bootloader.bin
  │   ├── partitions.bin
  │   └── app.bin
  └── esp32s3/
      ├── bootloader.bin
      ├── partitions.bin
      └── app.bin</code></pre>

            <h3>Full API Options</h3>
            <pre><code class="language-javascript">await router.flash({
    // Required: Configuration to write to NVS
    config: {
        wifi: { ssid: "Network", password: "pass" },
        device: { id: "ESP32_001" }
    },

    // Optional: NVS partition size (default: 0x6000 / 24KB)
    nvsSize: 0x6000,

    // Optional: Progress callback
    onProgress: (percent, stage) => {
        // stage: 'connecting', 'detecting', 'loading', 'flashing', 'complete'
        updateUI(percent, stage);
    },

    // Optional: Override automatic chip detection
    chipType: 'ESP32-C3',

    // Optional: Serial port (if not provided, prompts user)
    port: existingPort
});</code></pre>

            <h3>Implementation</h3>
            <p>Complete reference implementation demonstrating convention-based routing:</p>
            <pre><code class="language-javascript">class FirmwareRouter {
    constructor(basePath = '/firmware') {
        this.basePath = basePath;
        this.nvsGenerator = new NVSGenerator();
        this.chipMap = {
            'ESP32': 'esp32',
            'ESP32-C3': 'esp32c3',
            'ESP32-S3': 'esp32s3',
            'ESP32-S2': 'esp32s2',
            'ESP32-C6': 'esp32c6'
        };
    }

    async flash(options) {
        const {
            config,
            nvsSize = 0x6000,
            onProgress = () => {},
            chipType = null,
            port = null
        } = options;

        // Stage 1: Connect to device
        onProgress(0, 'connecting');
        const serialPort = port || await navigator.serial.requestPort({
            filters: [{ usbVendorId: 0x303a }]  // Espressif
        });

        const transport = new Transport(serialPort);
        const esploader = new ESPLoader(transport, 115200);
        await esploader.connect();

        // Stage 2: Detect chip type
        onProgress(20, 'detecting');
        const detectedChip = chipType || esploader.chipName;
        const chipDir = this.chipMap[detectedChip];

        if (!chipDir) {
            throw new Error(`Unsupported chip: ${detectedChip}`);
        }

        // Stage 3: Load firmware binaries
        onProgress(30, 'loading');
        const [bootloader, partitions, app] = await Promise.all([
            fetch(`${this.basePath}/${chipDir}/bootloader.bin`).then(r => r.arrayBuffer()),
            fetch(`${this.basePath}/${chipDir}/partitions.bin`).then(r => r.arrayBuffer()),
            fetch(`${this.basePath}/${chipDir}/app.bin`).then(r => r.arrayBuffer())
        ]);

        // Stage 4: Generate NVS partition
        const nvsBinary = this.nvsGenerator.generate(config, nvsSize);

        // Stage 5: Flash all binaries
        onProgress(50, 'flashing');
        const fileArray = [
            { data: this._toStr(bootloader), address: 0x1000 },
            { data: this._toStr(partitions), address: 0x8000 },
            { data: this._toStr(nvsBinary), address: 0x9000 },
            { data: this._toStr(app), address: 0x10000 }
        ];

        await esploader.writeFlash({
            fileArray,
            flashSize: 'keep',
            compress: true,
            reportProgress: (idx, written, total) => {
                const percent = 50 + Math.round((written / total) * 45);
                onProgress(percent, 'flashing');
            }
        });

        onProgress(100, 'complete');
        await esploader.hardReset();
    }

    _toStr(buffer) {
        const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
        let str = '';
        for (let i = 0; i < bytes.length; i++) {
            str += String.fromCharCode(bytes[i]);
        }
        return str;
    }
}</code></pre>

            <h3>Complete Example</h3>
            <pre><code class="language-javascript">// HTML button handler
document.getElementById('flashBtn').addEventListener('click', async () => {
    const router = new FirmwareRouter('/firmware');

    const config = {
        wifi: {
            ssid: document.getElementById('ssid').value,
            password: document.getElementById('password').value
        },
        device: {
            id: `DEV_${Date.now()}`
        }
    };

    try {
        await router.flash({
            config,
            onProgress: (percent, stage) => {
                document.getElementById('progress').value = percent;
                document.getElementById('status').textContent = stage;
            }
        });

        alert('Device flashed successfully!');
    } catch (err) {
        alert(`Flash failed: ${err.message}`);
    }
});</code></pre>

            <h3>Operational Flow</h3>
            <div style="background: var(--bg-secondary); border: 1px solid rgba(0,0,0,0.08); border-radius: 12px; padding: 32px 40px; margin: 32px 0;">
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 16px;">
                    <!-- Step 1 -->
                    <div style="flex: 1; text-align: center;">
                        <div style="width: 52px; height: 52px; margin: 0 auto 12px; background: linear-gradient(135deg, rgba(0,122,255,0.08) 0%, rgba(0,122,255,0.04) 100%); border: 1px solid rgba(0,122,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 600; color: #007AFF; box-shadow: 0 2px 6px rgba(0,122,255,0.1), inset 0 1px 0 rgba(255,255,255,0.4);">1</div>
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; letter-spacing: -0.01em;">Call</div>
                        <div style="font-size: 12px; color: var(--text-secondary); font-family: 'SF Mono', Monaco, monospace; background: var(--bg-tertiary); padding: 4px 8px; border-radius: 4px; display: inline-block;">router.flash()</div>
                    </div>

                    <!-- Arrow -->
                    <div style="flex: 0 0 auto; color: var(--text-tertiary); font-size: 20px; margin: 0 -4px;">→</div>

                    <!-- Step 2 -->
                    <div style="flex: 1; text-align: center;">
                        <div style="width: 52px; height: 52px; margin: 0 auto 12px; background: linear-gradient(135deg, rgba(0,122,255,0.08) 0%, rgba(0,122,255,0.04) 100%); border: 1px solid rgba(0,122,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 600; color: #007AFF; box-shadow: 0 2px 6px rgba(0,122,255,0.1), inset 0 1px 0 rgba(255,255,255,0.4);">2</div>
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; letter-spacing: -0.01em;">Detect</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">Chip identified</div>
                    </div>

                    <!-- Arrow -->
                    <div style="flex: 0 0 auto; color: var(--text-tertiary); font-size: 20px; margin: 0 -4px;">→</div>

                    <!-- Step 3 -->
                    <div style="flex: 1; text-align: center;">
                        <div style="width: 52px; height: 52px; margin: 0 auto 12px; background: linear-gradient(135deg, rgba(0,122,255,0.08) 0%, rgba(0,122,255,0.04) 100%); border: 1px solid rgba(0,122,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 600; color: #007AFF; box-shadow: 0 2px 6px rgba(0,122,255,0.1), inset 0 1px 0 rgba(255,255,255,0.4);">3</div>
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; letter-spacing: -0.01em;">Route</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">Binaries loaded</div>
                    </div>

                    <!-- Arrow -->
                    <div style="flex: 0 0 auto; color: var(--text-tertiary); font-size: 20px; margin: 0 -4px;">→</div>

                    <!-- Step 4 -->
                    <div style="flex: 1; text-align: center;">
                        <div style="width: 52px; height: 52px; margin: 0 auto 12px; background: linear-gradient(135deg, rgba(0,122,255,0.08) 0%, rgba(0,122,255,0.04) 100%); border: 1px solid rgba(0,122,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 600; color: #007AFF; box-shadow: 0 2px 6px rgba(0,122,255,0.1), inset 0 1px 0 rgba(255,255,255,0.4);">4</div>
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; letter-spacing: -0.01em;">Generate</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">NVS created</div>
                    </div>

                    <!-- Arrow -->
                    <div style="flex: 0 0 auto; color: var(--text-tertiary); font-size: 20px; margin: 0 -4px;">→</div>

                    <!-- Step 5 -->
                    <div style="flex: 1; text-align: center;">
                        <div style="width: 52px; height: 52px; margin: 0 auto 12px; background: linear-gradient(135deg, rgba(52,168,83,0.08) 0%, rgba(52,168,83,0.04) 100%); border: 1px solid rgba(52,168,83,0.25); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 600; color: #34a853; box-shadow: 0 2px 6px rgba(52,168,83,0.12), inset 0 1px 0 rgba(255,255,255,0.4);"></div>
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 6px; letter-spacing: -0.01em;">Flash</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">Complete</div>
                    </div>
                </div>
            </div>

            <div class="callout">
                <div class="callout-title">Convention over configuration</div>
                <div class="callout-body">
                    The router requires no mapping configuration. Directory structure conventions determine firmware paths.
                    Chip variant support is automatic—add a new directory (e.g., esp32c6/) with standard binary names, and the router handles it.
                    The entire flashing workflow reduces to a single method call with a configuration object.
                    Serial port selection, chip detection, binary fetching, NVS generation, and flash operations execute transparently.
                </div>
            </div>

            <h3>Build Automation</h3>
            <p>Firmware directory population can be automated from ESP-IDF build artifacts:</p>
            <pre><code class="language-javascript">// deploy-firmware.js - runs after ESP-IDF builds
const fs = require('fs');
const path = require('path');

const targets = ['esp32', 'esp32c3', 'esp32s3'];

targets.forEach(target => {
    const buildDir = `build_${target}`;
    const outputDir = `web/firmware/${target}`;

    // Create output directory
    fs.mkdirSync(outputDir, { recursive: true });

    // Copy binaries to conventional locations
    fs.copyFileSync(
        `${buildDir}/bootloader/bootloader.bin`,
        `${outputDir}/bootloader.bin`
    );
    fs.copyFileSync(
        `${buildDir}/partition_table/partition-table.bin`,
        `${outputDir}/partitions.bin`
    );
    fs.copyFileSync(
        `${buildDir}/firmware.bin`,
        `${outputDir}/app.bin`
    );

    console.log(` Deployed ${target}`);
});</code></pre>

            <h3>CI/CD Integration</h3>
            <pre><code class="language-yaml"># .github/workflows/build-firmware.yml
name: Build Multi-Platform Firmware
on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: [esp32, esp32c3, esp32s3]

    steps:
      - uses: actions/checkout@v3
      - uses: espressif/esp-idf-ci-action@v1
        with:
          esp_idf_version: v5.1
          target: ${{ matrix.target }}

      - name: Build firmware
        run: |
          idf.py set-target ${{ matrix.target }}
          idf.py build

      - name: Deploy to web directory
        run: |
          mkdir -p web/firmware/${{ matrix.target }}
          cp build/bootloader/bootloader.bin web/firmware/${{ matrix.target }}/
          cp build/partition_table/partition-table.bin web/firmware/${{ matrix.target }}/partitions.bin
          cp build/firmware.bin web/firmware/${{ matrix.target }}/app.bin

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: firmware-${{ matrix.target }}
          path: web/firmware/${{ matrix.target }}/</code></pre>

            <div class="callout">
                <div class="callout-title">Zero-configuration deployment</div>
                <div class="callout-body">
                    CI/CD pipelines build firmware for all target chips, deploy binaries to conventional paths, and publish to web servers.
                    The router automatically supports new chip variants when directories appear—no code changes, no configuration files, no manual synchronization.
                    Adding ESP32-C6 support requires only adding the target to the build matrix. The router detects and routes to it immediately.
                </div>
            </div>
        </div>


        <!-- Flash -->
    </div>

    <script src="shared-nav.js"></script>
    <script src="docs-scripts.js"></script>
    <script src="docs-sidebar.js"></script>
</body>
</html>
