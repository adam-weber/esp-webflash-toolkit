{
  "version": 3,
  "sources": ["../src/nvs-generator.js"],
  "sourcesContent": ["/**\n * NVS Partition Generator for ESP32\n *\n * Generates NVS (Non-Volatile Storage) partition binaries that can be flashed\n * to ESP32 devices. This is a client-side JavaScript implementation of the\n * ESP-IDF nvs_partition_gen.py functionality.\n *\n * NVS Format:\n * - Partition divided into pages (4096 bytes each)\n * - Each page contains entries (32 bytes each)\n * - First page contains partition state\n * - Entries store key-value pairs with type information\n */\n\nclass NVSGenerator {\n    constructor() {\n        this.PAGE_SIZE = 4096;\n        this.ENTRY_SIZE = 32;\n        this.ENTRIES_PER_PAGE = 126; // (4096 - 32) / 32\n\n        // NVS entry types\n        this.TYPE_U8 = 0x01;\n        this.TYPE_I8 = 0x11;\n        this.TYPE_U16 = 0x02;\n        this.TYPE_I16 = 0x12;\n        this.TYPE_U32 = 0x04;\n        this.TYPE_I32 = 0x14;\n        this.TYPE_STR = 0x21;\n        this.TYPE_BLOB = 0x41;\n\n        // Page states\n        this.PAGE_STATE_ACTIVE = 0xFFFFFFFE;\n        this.PAGE_STATE_FULL = 0xFFFFFFFC;\n        this.PAGE_STATE_EMPTY = 0xFFFFFFFF;\n    }\n\n    /**\n     * Generate NVS partition binary from key-value pairs\n     * @param {Object} data - Key-value pairs organized by namespace\n     * @param {number} partitionSize - Size of partition in bytes (default: 0x6000 = 24KB)\n     * @returns {Uint8Array} - Binary data ready to flash\n     */\n    generate(data, partitionSize = 0x6000) {\n        const numPages = Math.floor(partitionSize / this.PAGE_SIZE);\n        const binary = new Uint8Array(partitionSize);\n        binary.fill(0xFF); // Initialize with 0xFF (erased flash state)\n\n        let pageIndex = 0;\n        let entryIndex = 1;  // Start at 1 (entry 0 reserved for bitmap)\n        let namespaceIndex = 0;  // Sequential namespace index\n\n        // Build namespace map\n        const namespaceMap = {};\n        for (const namespace of Object.keys(data)) {\n            if (Object.keys(data[namespace]).length > 0) {\n                namespaceMap[namespace] = ++namespaceIndex;\n            }\n        }\n\n        // Write bitmap entry at index 0 (ESP-IDF format)\n        // Bitmap marks which entries are in use (0xAA = first few entries used)\n        const bitmapOffset = pageIndex * this.PAGE_SIZE + 32;\n        binary[bitmapOffset] = 0xAA;  // Bitmap pattern\n        binary[bitmapOffset + 1] = 0xAA;\n\n        // Process each namespace\n        for (const [namespace, entries] of Object.entries(data)) {\n            // Add namespace entry if we have data\n            if (Object.keys(entries).length > 0) {\n                const nsIndex = namespaceMap[namespace];\n                this.writeEntry(binary, pageIndex, entryIndex++, {\n                    namespace: 0, // Namespace entries use index 0\n                    type: 0x01, // Namespace type (ESP-IDF uses 0x01)\n                    span: 1,\n                    key: namespace,\n                    data: new Uint8Array([nsIndex])  // Store the index in data\n                });\n\n                // Add key-value entries\n                for (const [key, value] of Object.entries(entries)) {\n                    const entry = this.createEntry(nsIndex, key, value);\n                    this.writeEntry(binary, pageIndex, entryIndex, entry);\n                    entryIndex += entry.span; // Increment by span, not just 1\n\n                    // Move to next page if current page is full\n                    if (entryIndex >= this.ENTRIES_PER_PAGE) {\n                        this.finalizePage(binary, pageIndex, entryIndex);\n                        pageIndex++;\n                        entryIndex = 1;  // Start at 1 (entry 0 reserved for bitmap)\n\n                        // Write bitmap for new page\n                        const newBitmapOffset = pageIndex * this.PAGE_SIZE + 32;\n                        binary[newBitmapOffset] = 0xAA;\n                        binary[newBitmapOffset + 1] = 0xAA;\n\n                        if (pageIndex >= numPages) {\n                            throw new Error('NVS partition size too small for data');\n                        }\n                    }\n                }\n            }\n        }\n\n        // Finalize last page\n        if (entryIndex > 0) {\n            this.finalizePage(binary, pageIndex, entryIndex);\n        }\n\n        return binary;\n    }\n\n    /**\n     * Create an NVS entry from a key-value pair\n     */\n    createEntry(namespaceIndex, key, value) {\n        let type, data;\n\n        if (typeof value === 'string') {\n            type = this.TYPE_STR;\n            const encoder = new TextEncoder();\n            const strBytes = encoder.encode(value);\n            data = new Uint8Array(strBytes.length + 1); // +1 for null terminator\n            data.set(strBytes);\n            data[strBytes.length] = 0; // Null terminator\n            console.log(`[NVS Writer] Key: ${key}, value: \"${value}\", data.length: ${data.length}, bytes:`, Array.from(data));\n        } else if (typeof value === 'number') {\n            if (Number.isInteger(value)) {\n                if (value >= 0 && value <= 255) {\n                    type = this.TYPE_U8;\n                    data = new Uint8Array([value]);\n                } else if (value >= 0 && value <= 65535) {\n                    type = this.TYPE_U16;\n                    data = new Uint8Array(2);\n                    new DataView(data.buffer).setUint16(0, value, true); // little-endian\n                } else {\n                    type = this.TYPE_U32;\n                    data = new Uint8Array(4);\n                    new DataView(data.buffer).setUint32(0, value, true); // little-endian\n                }\n            } else {\n                throw new Error('Float values not supported yet');\n            }\n        } else {\n            throw new Error(`Unsupported value type for key ${key}: ${typeof value}`);\n        }\n\n        // Calculate span correctly:\n        // - Strings/blobs ALWAYS use at least 2 entries (span >= 2)\n        // - First entry: metadata (length at offset 24)\n        // - Second+ entries: data (32 bytes per entry)\n        let span = 1;\n        if (type === this.TYPE_STR || type === this.TYPE_BLOB) {\n            // Minimum span is 2 for strings/blobs\n            span = 1 + Math.ceil(data.length / this.ENTRY_SIZE);\n        } else {\n            // For numeric types, span is always 1\n            span = 1;\n        }\n\n        return {\n            namespace: namespaceIndex,  // Use sequential index\n            type: type,\n            span: span,\n            key: key,\n            data: data\n        };\n    }\n\n    /**\n     * Write an entry to the binary at the specified page and entry index\n     */\n    writeEntry(binary, pageIndex, entryIndex, entry) {\n        const offset = pageIndex * this.PAGE_SIZE + 32 + entryIndex * this.ENTRY_SIZE;\n        const view = new DataView(binary.buffer);\n\n        // Entry format (32 bytes) - ESP-IDF official format:\n        // [0] Namespace (1 byte)\n        // [1] Type (1 byte)\n        // [2] Span (1 byte)\n        // [3] Reserved (1 byte)\n        // [4-7] CRC32 (4 bytes)\n        // [8-23] Key (16 bytes, null-padded)\n        // [24-31] Data (8 bytes for values \u22648 bytes)\n\n        binary[offset + 0] = entry.namespace;\n        binary[offset + 1] = entry.type;\n        binary[offset + 2] = entry.span;\n        binary[offset + 3] = 0xFF; // Reserved\n\n        // Write key (max 15 chars + null terminator)\n        const keyBytes = new TextEncoder().encode(entry.key.substring(0, 15));\n        binary.set(keyBytes, offset + 8);  // Key starts at offset 8\n        for (let i = keyBytes.length; i < 16; i++) {\n            binary[offset + 8 + i] = 0;\n        }\n\n        // For strings/blobs, write length at offset 24, ALL data goes to continuation entries\n        if (entry.type === this.TYPE_STR || entry.type === this.TYPE_BLOB) {\n            view.setUint16(offset + 24, entry.data.length, true);  // Length at offset 24-25\n            // Bytes 26-31 are unused/padding (0xFF)\n\n            // ALL string data goes into continuation entries (starting from entry index + 1)\n            let dataOffset = 0;\n            for (let i = 1; i < entry.span; i++) {\n                const nextEntryOffset = offset + i * this.ENTRY_SIZE;\n                const chunk = entry.data.slice(dataOffset, dataOffset + this.ENTRY_SIZE);\n                binary.set(chunk, nextEntryOffset);\n                dataOffset += this.ENTRY_SIZE;\n            }\n        } else {\n            // Numeric types: write data inline at offset 24\n            binary.set(entry.data, offset + 24);\n        }\n\n        // Calculate and write CRC32 at offset 4-7\n        // CRC is calculated over: namespace(1) + type(1) + span(1) + reserved(1) + key(16) + data(8) = 28 bytes\n        const crcData = new Uint8Array(28);\n        crcData[0] = binary[offset + 0];  // namespace\n        crcData[1] = binary[offset + 1];  // type\n        crcData[2] = binary[offset + 2];  // span\n        crcData[3] = binary[offset + 3];  // reserved\n        crcData.set(binary.slice(offset + 8, offset + 24), 4);   // key (16 bytes)\n        crcData.set(binary.slice(offset + 24, offset + 32), 20); // data (8 bytes)\n\n        const crc = this.calculateCRC32(crcData);\n        view.setUint32(offset + 4, crc, true);  // CRC at offset 4\n    }\n\n    /**\n     * Finalize a page by writing the page header\n     */\n    finalizePage(binary, pageIndex, numEntries) {\n        const offset = pageIndex * this.PAGE_SIZE;\n        const view = new DataView(binary.buffer);\n\n        // Page header (32 bytes):\n        // [0-3] Page state (4 bytes)\n        // [4-7] Sequence number (4 bytes)\n        // [8-11] Version (4 bytes) - set to 0xFFFFFFFF (unused)\n        // [12-31] Reserved\n\n        view.setUint32(offset + 0, this.PAGE_STATE_ACTIVE, true);\n        view.setUint32(offset + 4, pageIndex, true); // Sequence number\n        view.setUint32(offset + 8, 0xFFFFFFFF, true); // Version (unused)\n\n        // Calculate page CRC and store at end of header\n        const headerCRC = this.calculateCRC32(binary.slice(offset, offset + 28));\n        view.setUint32(offset + 28, headerCRC, true);\n    }\n\n\n    /**\n     * Calculate CRC32 checksum\n     * This is a simplified implementation - ESP-IDF uses proper CRC32\n     */\n    calculateCRC32(data) {\n        let crc = 0xFFFFFFFF;\n\n        for (let i = 0; i < data.length; i++) {\n            crc ^= data[i];\n            for (let j = 0; j < 8; j++) {\n                crc = (crc >>> 1) ^ (0xEDB88320 & -(crc & 1));\n            }\n        }\n\n        return ~crc >>> 0; // Convert to unsigned 32-bit\n    }\n}\n\n/**\n * Helper function to generate NVS partition from web form inputs\n * @param {Object} config - Configuration object from form\n * @param {string} namespace - NVS namespace (default: 'config')\n * @param {number} partitionSize - Partition size in bytes\n * @returns {Uint8Array} - NVS partition binary\n */\nfunction generateNVSFromConfig(config, namespace = 'config', partitionSize = 0x6000) {\n    const generator = new NVSGenerator();\n\n    // Flatten config structure into namespace data\n    const nvsData = {};\n    nvsData[namespace] = {};\n\n    for (const [section, fields] of Object.entries(config)) {\n        for (const [field, value] of Object.entries(fields)) {\n            // Create NVS key from section and field (e.g., 'wifi_ssid')\n            const key = `${section}_${field}`;\n            nvsData[namespace][key] = value;\n        }\n    }\n\n    return generator.generate(nvsData, partitionSize);\n}\n\n/**\n * Parse NVS partition binary back into key-value pairs\n * @param {Uint8Array} binary - NVS partition binary data\n * @returns {Object} - Parsed data organized by namespace\n */\nNVSGenerator.prototype.parse = function(binary) {\n    const data = {};\n    const namespaces = {}; // Map namespace index to name\n\n    const view = new DataView(binary.buffer, binary.byteOffset, binary.byteLength);\n    const numPages = Math.floor(binary.length / this.PAGE_SIZE);\n\n    for (let pageIdx = 0; pageIdx < numPages; pageIdx++) {\n        const pageOffset = pageIdx * this.PAGE_SIZE;\n\n        // Read page header\n        const pageState = view.getUint32(pageOffset, true);\n\n        // Skip empty or invalid pages\n        if (pageState === this.PAGE_STATE_EMPTY || pageState === 0) {\n            continue;\n        }\n\n        // Read entries in this page (start at 1, entry 0 is bitmap)\n        for (let entryIdx = 1; entryIdx < this.ENTRIES_PER_PAGE; ) {\n            const entryOffset = pageOffset + 32 + (entryIdx * this.ENTRY_SIZE);\n\n            // Check if entry is used (namespace byte != 0xFF)\n            const namespace = view.getUint8(entryOffset);\n            if (namespace === 0xFF) {\n                entryIdx++;\n                continue; // Empty entry\n            }\n\n            const type = view.getUint8(entryOffset + 1);\n            const span = view.getUint8(entryOffset + 2);\n\n            // Read key (16 bytes, null-terminated) - starts at offset 8\n            const keyBytes = new Uint8Array(binary.buffer, binary.byteOffset + entryOffset + 8, 16);\n            const keyEnd = keyBytes.indexOf(0);\n            const key = new TextDecoder().decode(keyBytes.slice(0, keyEnd > 0 ? keyEnd : 16));\n\n            // Handle namespace entries (type 0x01 AND namespace 0)\n            if (type === 0x01 && namespace === 0) {\n                // Namespace entries have index 0, actual index is in data[0]\n                const nsIndex = view.getUint8(entryOffset + 24);\n                namespaces[nsIndex] = key;\n                if (!data[key]) {\n                    data[key] = {};\n                }\n                entryIdx += span;\n                continue;\n            }\n\n            // Get namespace name\n            const namespaceName = namespaces[namespace] || `ns_${namespace}`;\n            if (!data[namespaceName]) {\n                data[namespaceName] = {};\n            }\n\n            // Parse value based on type\n            let value;\n\n            if (type === this.TYPE_U8) {\n                value = view.getUint8(entryOffset + 24);\n            } else if (type === this.TYPE_I8) {\n                value = view.getInt8(entryOffset + 24);\n            } else if (type === this.TYPE_U16) {\n                value = view.getUint16(entryOffset + 24, true);\n            } else if (type === this.TYPE_I16) {\n                value = view.getInt16(entryOffset + 24, true);\n            } else if (type === this.TYPE_U32) {\n                value = view.getUint32(entryOffset + 24, true);\n            } else if (type === this.TYPE_I32) {\n                value = view.getInt32(entryOffset + 24, true);\n            } else if (type === this.TYPE_STR) {\n                // String: length at offset+24 (2 bytes), ALL data in continuation entries\n                const strLen = view.getUint16(entryOffset + 24, true);\n                const totalBytes = new Uint8Array(strLen);\n                let bytesRead = 0;\n\n                // Read from continuation entries ONLY (skip first entry, it only has length)\n                for (let s = 1; s < span; s++) {\n                    const spanOffset = entryOffset + (s * this.ENTRY_SIZE);\n                    const chunkSize = Math.min(strLen - bytesRead, this.ENTRY_SIZE);\n\n                    totalBytes.set(\n                        new Uint8Array(binary.buffer, binary.byteOffset + spanOffset, chunkSize),\n                        bytesRead\n                    );\n                    bytesRead += chunkSize;\n                }\n\n                // Find null terminator and decode only up to that point\n                const nullIndex = totalBytes.indexOf(0);\n                const actualLen = nullIndex >= 0 ? nullIndex : strLen;\n                console.log(`[NVS Parser] Key: ${key}, strLen: ${strLen}, span: ${span}, bytes:`, Array.from(totalBytes.slice(0, actualLen + 1)));\n                value = new TextDecoder().decode(totalBytes.slice(0, actualLen));\n            } else if (type === this.TYPE_BLOB) {\n                // Blob: similar to string but return as Uint8Array\n                const blobLen = view.getUint16(entryOffset + 20, true);\n                value = new Uint8Array(binary.buffer, binary.byteOffset + entryOffset + 24, Math.min(blobLen, 8));\n            } else {\n                // Unknown type\n                entryIdx++;\n                continue;\n            }\n\n            data[namespaceName][key] = value;\n            entryIdx += span;  // Skip span entries (includes this one + continuation entries)\n        }\n    }\n\n    return data;\n};\n\n/**\n * Parse NVS partition and return config matching the expected structure\n * @param {Uint8Array} binary - NVS partition binary data\n * @param {string} namespace - Expected namespace (default: 'config')\n * @returns {Object} - Parsed config with nvsKey mappings\n */\nfunction parseNVSConfig(binary, namespace = 'config') {\n    const generator = new NVSGenerator();\n    const parsed = generator.parse(binary);\n\n    // Return the namespace data directly\n    return parsed[namespace] || {};\n}\n\n// ES6 export for module usage\nexport { NVSGenerator, generateNVSFromConfig, parseNVSConfig };\n\n// Also expose globally for browser usage (legacy compatibility)\nif (typeof window !== 'undefined') {\n    window.NVSGenerator = NVSGenerator;\n    window.generateNVSFromConfig = generateNVSFromConfig;\n    window.parseNVSConfig = parseNVSConfig;\n}\n"],
  "mappings": "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",
  "names": ["NVSGenerator", "data", "partitionSize", "numPages", "binary", "pageIndex", "entryIndex", "namespaceIndex", "namespaceMap", "namespace", "bitmapOffset", "entries", "nsIndex", "key", "value", "entry", "newBitmapOffset", "type", "strBytes", "span", "offset", "view", "keyBytes", "i", "dataOffset", "nextEntryOffset", "chunk", "crcData", "crc", "numEntries", "headerCRC", "j", "generateNVSFromConfig", "config", "generator", "nvsData", "section", "fields", "field", "namespaces", "pageIdx", "pageOffset", "pageState", "entryIdx", "entryOffset", "keyEnd", "namespaceName", "strLen", "totalBytes", "bytesRead", "s", "spanOffset", "chunkSize", "nullIndex", "actualLen", "blobLen", "parseNVSConfig"]
}
